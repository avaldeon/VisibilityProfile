# -*- coding: utf-8 -*-
"""
/***************************************************************************
 VisibilityProfileDialog
                                 A QGIS plugin
 This plugin make images with a graph drawing a profile between two points (the observer and the observed feature) and the visibility between these two points at the highest point of them
 Base generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-10-11
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Aitor Valdeón - Forestalia Renovables S.L.
        email                : avaldeon@forestalia.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

# from qgis.PyQt import uic # Anterior
from PyQt5 import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtWidgets import QDialog, QComboBox, QToolButton, QFileDialog, QApplication, QMessageBox
from PyQt5.QtCore import Qt
from qgis.core import QgsRaster, QgsRasterLayer, QgsProject, QgsGeometry, QgsFeature, QgsPointXY
import numpy as np
import matplotlib.pyplot as plt


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'visibility_profile_dialog_base.ui'))



class VisibilityProfileDialog(QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(VisibilityProfileDialog, self).__init__(parent)

        # Cargar interfaz de usuario
        self.setupUi(self)        

        self.buttonsWidget.setMaximumHeight(60)	
        self.buttonsWidget.setMinimumHeight(60)	
        self.outputFileWidget.setMaximumHeight(130)	
        self.outputFileWidget.setMinimumHeight(130)	
        self.demLayerWidget.setMaximumHeight(80)	
        self.demLayerWidget.setMinimumHeight(80)	
        self.separateLayersWidget.setMaximumHeight(90)	
        self.separateLayersWidget.setMinimumHeight(90)
        self.groupBox.setMaximumHeight(80)	
        self.groupBox.setMinimumHeight(80)
        self.coordinatesWidget.setMaximumHeight(90)	
        self.coordinatesWidget.setMinimumHeight(90)
        self.optionsWidget.setMaximumHeight(120)	
        self.optionsWidget.setMinimumHeight(120)


        # Variables
        self.capa_raster_seleccionada = None
        self.capa_observador = None
        self.capa_objetivo = None
        self.observer_point = None
        self.target_point = None
        self.observer_h = None
        self.target_h = None
        self.output_file = ''
        self.terrain_line = True
        self.target_line = True
        self.legend_visibility = True
        self.legend_profile = True
        self.legend_points = True
        self.relleno_grafico = True
        self.color_visible = 'red'
        self.color_no_visible = 'green'
        self.graph_title = ''       
		# Conectar señal de visibilidad de opciones de entrada de puntos
        self.PointSelectionMethodComboBox.currentIndexChanged.connect(self.actualizar_visibilidad)
        # Cargar capas raster en el diálogo
        self.cargar_capas_raster()
        # Cargar capas vectoriales en el diálogo
        self.cargar_capas_vectoriales()
        # Conectar el QToolButton del MDT a la función que abre el diálogo de archivos
        self.toolButtonMDTFile.clicked.connect(self.abrir_dialogo_archivo_raster)
        # Conectar el QToolButton al método que abrirá el diálogo de guardar archivo
        self.toolButtonOutputFile.clicked.connect(self.seleccionar_archivo_salida)
        # Conectar los QCheckBox a la función de cambio de estado
        self.checkBoxLineaVisionTerreno.stateChanged.connect(self.cambio_estado_checkBoxLineaVisionTerreno)
        self.checkBoxLineaVisionObjeto.stateChanged.connect(self.cambio_estado_checkBoxLineaVisionObjeto)
        self.checkBoxSimbolVisibilidad.stateChanged.connect(self.cambio_estado_checkBoxSimbolVisibilidad)
        self.checkBoxPerfilLeyenda.stateChanged.connect(self.cambio_estado_checkBoxPerfilLeyenda)
        self.checkBoxPuntosLeyenda.stateChanged.connect(self.cambio_estado_checkBoxPuntosLeyenda)
        self.checkBoxRellenoGrafico.stateChanged.connect(self.cambio_estado_checkBoxRellenoGrafico)
        self.checkBoxRojoVisible.stateChanged.connect(self.cambio_estado_checkBoxRojoVisible)

        # Conectar el QPushButton "Cerrar" al método cerrar toda la aplicación
        self.closePushButton.clicked.connect(self.close)
        # Conectar el QPushButton "Ejecutar" al método que ejecuta la herramienta
        self.runPushButton.clicked.connect(self.generate_profile)

		
    def cambio_estado_checkBoxRojoVisible(self, estado):
        if estado == Qt.Checked:
            self.color_visible = 'red'
            self.color_no_visible = 'green'
        elif estado == Qt.Unchecked:
            self.color_visible = 'green'
            self.color_no_visible = 'red'

    def cambio_estado_checkBoxRellenoGrafico(self, estado):
        if estado == Qt.Checked:
            self.relleno_grafico = True
        elif estado == Qt.Unchecked:
            self.relleno_grafico = False

    def cambio_estado_checkBoxPuntosLeyenda(self, estado):
        if estado == Qt.Checked:
            self.legend_points = True
        elif estado == Qt.Unchecked:
            self.legend_points = False

    def cambio_estado_checkBoxPerfilLeyenda(self, estado):
        if estado == Qt.Checked:
            self.legend_profile = True
        elif estado == Qt.Unchecked:
            self.legend_profile = False

    def cambio_estado_checkBoxSimbolVisibilidad(self, estado):
        if estado == Qt.Checked:
            self.legend_visibility = True
        elif estado == Qt.Unchecked:
            self.legend_visibility = False

    def cambio_estado_checkBoxLineaVisionObjeto(self, estado):
        if estado == Qt.Checked:
            self.target_line = True
        elif estado == Qt.Unchecked:
            self.target_line = False

    def cambio_estado_checkBoxLineaVisionTerreno(self, estado):
        if estado == Qt.Checked:
            self.terrain_line = True
        elif estado == Qt.Unchecked:
            self.terrain_line = False
     
		
    def actualizar_visibilidad(self):
            #Para cambiar la visibilidad de la forma de meter las coordenadas
            indice = self.PointSelectionMethodComboBox.currentIndex()
			
			# Si el índice 0 está seleccionado, ocultar los cuadros de selección de puntos
            if indice == 0:
                self.coordinatesWidget.setVisible(False)
                self.separateLayersWidget.setVisible(False)
        
            # Si el índice 1 está seleccionado, mostrar el QGroupBox para introducir las coordenadas manualmente
            elif indice == 1:
                self.coordinatesWidget.setVisible(True)
                self.separateLayersWidget.setVisible(False)

            # Si el índice 2 está seleccionado, mostrar el QGroupBox para seleccionar archivos de puntos
            elif indice == 2:
                self.coordinatesWidget.setVisible(False)
                self.separateLayersWidget.setVisible(True)

    def cargar_capas_raster(self):
        # Limpiar el QComboBox antes de cargar los nombres de las capas ráster
        self.demLayerComboBox.clear()

        # Obtener todas las capas cargadas en el proyecto
        capas = QgsProject.instance().mapLayers().values()

        # Cargar item vacío
        self.demLayerComboBox.addItem('','')

        # Iterar sobre las capas y verificar si son capas ráster
        for capa in capas:
            if isinstance(capa, QgsRasterLayer):
                # Si es una capa ráster, agregar su nombre al QComboBox
                self.demLayerComboBox.addItem(capa.name(), capa.id())	

    def cargar_capas_vectoriales(self):
        """Rellena el QComboBox con las capas vectoriales del proyecto."""
        # Obtener todas las capas cargadas en el proyecto
        capas = QgsProject.instance().mapLayers().values()

        # Limpiar el QComboBox antes de agregar nuevas capas
        self.observerLayerComboBox.clear()

        #Cargar item vacío
        self.observerLayerComboBox.addItem('','')
        self.targetLayerComboBox.addItem('','')
		
        # Iterar sobre las capas y filtrar solo las capas vectoriales
        for capa in capas:
            if capa.type() == capa.VectorLayer:  # Verificar si es una capa vectorial
                self.observerLayerComboBox.addItem(capa.name(), capa.id())  # Agregar al QComboBox
                self.targetLayerComboBox.addItem(capa.name(), capa.id())  # Agregar al QComboBox				

    def abrir_dialogo_archivo_raster(self):
        """Abre un diálogo de archivo para seleccionar un ráster desde el sistema de archivos."""
        # Abrir el diálogo para seleccionar un archivo ráster
        ruta_archivo, _ = QFileDialog.getOpenFileName(self, "Seleccionar archivo ráster", "", "Archivos ráster (*.tif *.img *.asc)")

        # Si se selecciona un archivo válido
        if ruta_archivo:
            # Verificar si el archivo existe
            if os.path.exists(ruta_archivo):
                self.cargar_archivo_raster(ruta_archivo)

    def cargar_archivo_raster(self, ruta_archivo):
        """Cargar un archivo ráster como objeto QgsRasterLayer sin añadirlo al proyecto."""
        nombre_capa = os.path.basename(ruta_archivo)  # Extraer el nombre del archivo
        nueva_capa_raster = QgsRasterLayer(ruta_archivo, nombre_capa)

        # Verificar si la capa es válida
        if not nueva_capa_raster.isValid():
            print("El archivo seleccionado no es un ráster válido.")
            return

        # Guardar la capa en una variable para uso posterior
        self.capa_raster_seleccionada = nueva_capa_raster

        # Añadir el nombre de la capa al QComboBox sin agregarla al proyecto
        self.demLayerComboBox.addItem(nueva_capa_raster.name(), ruta_archivo)

        # (Opcional) Seleccionar automáticamente el nuevo ráster en el QComboBox
        indice_nuevo = self.demLayerComboBox.findText(nueva_capa_raster.name())
        if indice_nuevo != -1:
            self.demLayerComboBox.setCurrentIndex(indice_nuevo)

    def obtener_capa_raster(self, combobox):
        # Obtener el nombre de la capa seleccionada en el QComboBox
        nombre_capa_seleccionada = combobox.currentText()
    
        # Buscar la capa en el proyecto de QGIS por su nombre
        for capa in QgsProject.instance().mapLayers().values():
            if capa.name() == nombre_capa_seleccionada:
                return capa  # Devolver la capa encontrada (QgsVectorLayer)
        
		# Si es una ruta a archivo cargar desde la ruta
        try:
            return self.capa_raster_seleccionada	
        except:			
            return None  # Si no se encuentra la capa

    def obtener_capa_vectorial(self, combobox):
        # Obtener el nombre de la capa seleccionada en el QComboBox
        nombre_capa_seleccionada = combobox.currentText()
    
        # Buscar la capa en el proyecto de QGIS por su nombre
        for capa in QgsProject.instance().mapLayers().values():
            if capa.name() == nombre_capa_seleccionada:
                return capa  # Devolver la capa encontrada (QgsVectorLayer)

        return None  # Si no se encuentra la capa

    def seleccionar_archivo_salida(self):
        """Abrir un diálogo para seleccionar el archivo de salida y rellenar el QLineEdit con la ruta seleccionada."""
        # Abrir diálogo para guardar archivo
        ruta_archivo, _ = QFileDialog.getSaveFileName(self, "Guardar imagen como", "", "Archivos de imagen (*.png *.jpg *.tif)")

        # Si el usuario selecciona un archivo, establecer la ruta en el QLineEdit
        if ruta_archivo:
            self.outputLineEdit.setText(ruta_archivo)
            self.output_file = ruta_archivo
			
    def get_points_observer_target(self):
        #Para cambiar la visibilidad de la forma de meter las coordenadas
        indice = self.PointSelectionMethodComboBox.currentIndex()
        # Si el índice 0 está seleccionado, sacar mensaje de que hay que seleccionar un método de entrada de puntos de observador/objetivo
        if indice == 0:
            print("Debes introducir un método de selección de puntos de observador/objetivo.")
        
        # Si el índice 1 está seleccionado, mostrar el QGroupBox para introducir las coordenadas manualmente
        elif indice == 1:
            self.coordinatesWidget.setVisible(True)
            observer_x = float(self.observerXLineEdit.text())
            observer_y = float(self.observerYLineEdit.text())
            target_x = float(self.targetXLineEdit.text())
            target_y = float(self.targetYLineEdit.text())
        
            self.observer_point = QgsPointXY(observer_x, observer_y)
            self.target_point = QgsPointXY(target_x, target_y)


        # Si el índice 2 está seleccionado, mostrar el QGroupBox para seleccionar archivos de puntos
        elif indice == 2:
            self.capa_observador = self.obtener_capa_vectorial(self.observerLayerComboBox)
            self.capa_objetivo = self.obtener_capa_vectorial(self.targetLayerComboBox)
            self.observer_point = self.get_point_from_layer(self.capa_observador)
            self.target_point = self.get_point_from_layer(self.capa_objetivo)				

    def get_point_from_layer(self, point_layer):
        """Obtiene los puntos del observador y del objetivo desde la capa de puntos."""
        point = None
        if point_layer==None:
            QMessageBox.warning(self, "Datos necesarios faltantes", "Por favor, seleccione las capas de puntos de observador y objetivo.")
            return None
        # Iteramos sobre las entidades de la capa
        for feature in point_layer.getFeatures():
            geom = feature.geometry()
            point = geom.asPoint()  # Extraer el punto
        if point:
            return QgsPointXY(point)
        else:
            raise ValueError("Faltan puntos de observador u objetivo en la capa de puntos.")

    def get_elevation_at_point(self, layer, point):
        """Devuelve la elevación de un MDT en un punto específico."""
        # Identificación del valor de elevación en el punto especificado
        result = layer.dataProvider().identify(point, 1).results()  # '1' indica el primer canal del raster
        return result.get(1, None)  # Retorna la elevación o None si no está disponible

    #def generate_profile(self, layer, observer_point, self.observer_height, target_point, self.target_height, output_file, graph_title, iface):
    def generate_profile(self, iface):
        if self.PointSelectionMethodComboBox.currentIndex()==0:
            QMessageBox.warning(self, "Datos necesarios faltantes", "Por favor, elija el método de selección de puntos de observador/objetivo y selecciónelos.")
            return None
        x_label='Distancia (m)'
        y_label='Altitud (m)'
        self.graph_title = self.titleLineEdit.text()
        self.observer_h = float(self.observerHLineEdit.text())
        self.target_h = float(self.targetHLineEdit.text())

        # Cargar los puntos y trazar la línea entre ellos
        self.get_points_observer_target()
        line = QgsGeometry.fromPolylineXY([self.observer_point, self.target_point])
        
        # Determinamos la resolución del MDT (tamaño de píxel)
        layer = self.obtener_capa_raster(self.demLayerComboBox)
        if layer == None:
            QMessageBox.warning(self, "Datos necesarios faltantes", "Por favor, elija una capa raster con el modelo del terreno.")
            return None
        pixel_size_x = layer.rasterUnitsPerPixelX()
        pixel_size_y = layer.rasterUnitsPerPixelY()
        
        # Número de puntos a muestrear en la línea
        num_points = int(line.length() / max(pixel_size_x, pixel_size_y))
        
        # Generamos los puntos a lo largo de la línea con intervalos equidistantes
        total_distance = line.length()
        distances = np.linspace(0, total_distance, num_points + 1)
        
        points = [line.interpolate(d).asPoint() for d in distances]  # Puntos equidistantes

        # Obtenemos las elevaciones a lo largo de la línea
        elevations = []
        for p in points:
            elevation = self.get_elevation_at_point(layer, QgsPointXY(p))
            if elevation is not None:
                elevations.append(elevation)
            else:
                elevations.append(0)  # Si no se obtiene la elevación, se asigna 0 como valor predeterminado
        
        # Coordenadas en el espacio
        observer_z = elevations[0] + self.observer_h
        
        # Lista para almacenar los colores (verde, amarillo, rojo) y ángulo máximo
        colors = []
        max_angle = -np.inf  # Ángulo máximo inicial (para el terreno)

        # Cálculo de ángulos y visibilidad
        for i, (z, d) in enumerate(zip(elevations, distances)):
            if d == 0:  # El primer punto es el observador, lo tomamos como visible
                colors.append(self.color_visible)
                continue
            
            # Altura real del punto en el terreno
            z_actual = z
            z_with_object = z_actual + self.target_h  # Altura del objeto en cada punto

            # Calculamos el ángulo entre el observador y el punto actual (suelo)
            angle = np.arctan((z_actual - observer_z) / d)

            # Caso 1: El terreno es visible
            if angle > max_angle:
                max_angle = angle  # Actualizamos el ángulo máximo SOLO con el terreno
                colors.append(self.color_visible)  # El terreno es visible
            else:
                # Caso 2: El terreno no es visible, pero el objeto sí
                angle_with_object = np.arctan((z_with_object - observer_z) / d)
                if angle_with_object > max_angle:
                    colors.append('yellow')  # El objeto es visible, pero no el terreno
                else:
                    # Caso 3: Ni el terreno ni el objeto son visibles
                    colors.append(self.color_no_visible)

        # Graficamos el perfil topográfico
        plt.figure(figsize=(10, 5))
        if self.legend_profile == True:
            plt.plot(distances, elevations, label='Perfil del terreno', color='black')
        else:
            plt.plot(distances, elevations, color='black')
        if self.relleno_grafico == True:
            plt.fill_between(distances, elevations, observer_z, where=(np.array(colors) == self.color_no_visible), color=self.color_no_visible, alpha=0.5)
            plt.fill_between(distances, elevations, observer_z, where=(np.array(colors) == 'yellow'), color='yellow', alpha=0.5)
            plt.fill_between(distances, elevations, observer_z, where=(np.array(colors) == self.color_visible), color=self.color_visible, alpha=0.5)

        # Marcamos al observador y el objetivo
        if self.legend_points == True:
            plt.scatter(0, observer_z, color='blue', label='Observador (altura={} m)'.format(self.observer_h))
            plt.scatter(total_distance, elevations[-1] + self.target_h, color='orange', label='Objetivo (altura={} m)'.format(self.target_h))
        else:
            plt.scatter(0, observer_z, color='blue')
            plt.scatter(total_distance, elevations[-1] + self.target_h, color='orange')

        # Línea de visión (gris claro)
        if self.target_line == True:
            plt.plot([0, total_distance], [elevations[0] + self.observer_h, elevations[-1] + self.target_h], color='lightgray', linestyle='--')

        # Dibujar la línea de visión máxima extendida hasta el objetivo (gris oscuro)
        extended_max_elevation = elevations[0] + self.observer_h + np.tan(max_angle) * total_distance
        if self.terrain_line == True:        
            plt.plot([0, total_distance], [elevations[0] + self.observer_h, extended_max_elevation], color='darkgray', linestyle='--')

        # Línea vertical hacia el suelo desde el objetivo
        elevation_at_target = elevations[-1] if elevations else 0
        if colors[-1] == 'yellow':
            plt.plot([total_distance, total_distance], [elevations[-1] + self.target_h, extended_max_elevation], color='yellow', linewidth=2) #linestyle=':',
            plt.plot([total_distance, total_distance], [extended_max_elevation, elevation_at_target], color=self.color_no_visible, linewidth=2)
        else:
            plt.plot([total_distance, total_distance], [elevations[-1] + self.target_h, elevation_at_target], color=colors[-1], linestyle=':', linewidth=2)

        # Agregar leyenda de colores de visibilidad
        if self.legend_visibility == True:
            plt.scatter([], [], color=self.color_visible, marker='s', label='Visibilidad completa')   # Verde
            plt.scatter([], [], color='yellow', marker='s', label='Visibilidad parcial')   # Amarillo
            plt.scatter([], [], color=self.color_no_visible, marker='s', label='No visible')               # Rojo
        
        # Determinamos el color del objeto según su visibilidad
        object_angle = np.arctan((elevations[-1] + self.target_h - observer_z) / total_distance)
        if object_angle > max_angle:
            terrain_angle = np.arctan((elevations[-1] - observer_z) / total_distance)
            if terrain_angle == max_angle:
                plt.scatter(total_distance, elevations[-1] + self.target_h, color=self.color_visible)  # El objeto es visible totalmente
            else:
                plt.scatter(total_distance, elevations[-1] + self.target_h, color='yellow')  # El objeto es visible
        else:
            plt.scatter(total_distance, elevations[-1] + self.target_h, color=self.color_no_visible)  # El objeto no es visible
        
        plt.xlabel(x_label)
        plt.ylabel(y_label)
        plt.title(self.graph_title)
        plt.legend()
        plt.grid(True)

        # Guardar el gráfico en el archivo especificado
        if self.output_file!='':
            plt.savefig(self.output_file)
        plt.show()		
        # Cerrar la figura para no consumir memoria
        #plt.close()

